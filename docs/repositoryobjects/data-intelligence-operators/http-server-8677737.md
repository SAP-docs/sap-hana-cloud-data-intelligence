<!-- loio86777377f3b049cc98c080819c18eae3 -->

# HTTP Server

This operator allows a graph to accept HTTP requests on user-defined endpoints \(routes\) and respond to them based on messages produced on the fly by other operators in the graph.



Output ports must be created when designing the graph to accommodate the desired route multiplexing.

The sample graph `com.sap.demo.http.server` demonstrates some of the usage of this operator.

All configured routes will exist under a prefix that depends on the *graph handle* and the *operator ID*:

`/service/v1/graphs/<graph-handle>/operator/<operator-id>/`

This means that the URL will automatically be unique for every HTTP server in the graph as well as for every running instance of it, so the graph may run multiple times simultaneously. You can find the graph handle from the *Status* panel, and the operator ID from the Configuration panel.



<a name="loio86777377f3b049cc98c080819c18eae3__section_sq1_nf3_vdb"/>

## Configuration Parameters


<table>
<tr>
<th valign="top">

Title

</th>
<th valign="top">

ID

</th>
<th valign="top">

Type

</th>
<th valign="top">

Description

</th>
</tr>
<tr>
<td valign="top">

Routes

</td>
<td valign="top">

`routes` 

</td>
<td valign="top">

array

</td>
<td valign="top">

The list of routes the operator accepts. See Route Specification below for details.

Default: \[\]

</td>
</tr>
<tr>
<td valign="top">

Max Simultaneous Requests

</td>
<td valign="top">

`maxRequests` 

</td>
<td valign="top">

int

</td>
<td valign="top">

The maximum number of pending requests this operator can hold. A request is considered pending from the moment it is sent to the output port until a response is received from the input and sent to the client. This limit applies to requests globally, without taking into account whether they came from the same client or not. When this number is reached, all requests will be automatically responded to with status 503 Service Unavailable and the error message "simultaneous request limit reached" until at least one response arrives on the input for a pending request.

Default: 1

</td>
</tr>
</table>



<a name="loio86777377f3b049cc98c080819c18eae3__section_knq_5f3_vdb"/>

## Input


<table>
<tr>
<th valign="top">

Input

</th>
<th valign="top">

Type

</th>
<th valign="top">

Description

</th>
</tr>
<tr>
<td valign="top">

`response` 

</td>
<td valign="top">

message

</td>
<td valign="top">

A message describing how to respond to a pending request. The attribute`message.request.id` must be present and hold the value that was sent to the output port when the request was received.

</td>
</tr>
</table>

The body of the message, if present, will be used as the response payload. Objects and arrays will be encoded as JSON.

The HTTP status can be set with the http.status attribute \(an integer\) and defaults to 200 OK when the attribute is not present.



<a name="loio86777377f3b049cc98c080819c18eae3__section_swc_cg3_vdb"/>

## Output

By default, this operator comes without any outputs. Users must add as many output ports as they wish to multiplex the routes they configure. All outputs must be of type message. Each port will be used to output the requests for the route\(s\) associated to it in the route's configuration.

If the HTTP request has a payload, it will become the output message body.

The output message will have the following attributes:


<table>
<tr>
<th valign="top">

Output

</th>
<th valign="top">

Description

</th>
</tr>
<tr>
<td valign="top">

`message.request.id` 

</td>
<td valign="top">

A unique ID generated by the operator for this request. To respond this request, an input message must arrive at port `response` containing this ID.

</td>
</tr>
<tr>
<td valign="top">

`http.method` 

</td>
<td valign="top">

The request's HTTP method. This will necessarily be one of the route's `methods`.

</td>
</tr>
<tr>
<td valign="top">

`http.path` 

</td>
<td valign="top">

The complete path of the request, including the common prefix described in `basePath`.

</td>
</tr>
<tr>
<td valign="top">

`http.route` 

</td>
<td valign="top">

The route's own path, as set in the `routes` configuration.

</td>
</tr>
<tr>
<td valign="top">

`http.peer` 

</td>
<td valign="top">

The address of the client that made the request.

</td>
</tr>
<tr>
<td valign="top">

`http.vars` 

</td>
<td valign="top">

An object mapping URL variable names to their values.

</td>
</tr>
</table>



<a name="loio86777377f3b049cc98c080819c18eae3__section_mnz_skl_m3b"/>

## Route Specification

Each element in the route's array is an object with the following properties:

-   Path: the route's path, which will be accessible under a prefix as described in stableURL. No two routes can have the same path.

-   Outputs: an object that maps each supported HTTP method \(GET, POST, DELETE, and PUT\) to the name of the output port to which the operator will send the requests received for this endpoint with that method. A blank port name means the endpoint does not accept requests with that method, so those will be automatically replied to with status 405 Method Not Allowed.


If the port does not exist, an error will be raised during initialization.

If the port exists but is not connected \(so there is no operator to generate a response\), all requests to it will be automatically responded to with status 204 No Content.



### Route Variables

**Route paths** can have variables of two kinds: regular variables and catch-all variables. In both cases, the concrete value can be found in a message attribute named http.vars. This attribute is a map whose keys are the variables' names. The value for a variable is always a string. In a Go operator, the http.vars attribute has to be type-asserted to `map[string]string`:

```
func OnInput(val interface{}) {
    msg := val.(map[string]interface{})
    attributes := msg["Attributes"].(map[string]interface{})
    httpVars := attributes["http.vars"].(map[string]string)
    // ...
}
```

**Regular variables** take the form :myvar in the route's path. Each variable of this kind matches a single path segment.

For example, if a route has the `path /people/:name` and a request is made to /people/adam, a JavaScript operator can catch the output from HTTP Server and retrieve the requested person's name:

```
function onInput(ctx, msg) {
    console.log(msg.Attributes['http.vars']['name']); // Prints 'adam'
}
```

**Catch-all variables** take the form `*myvar` in the route's path. They must come at the end of the route's path and will match everything to the end of the requested path. They can also be empty. Retrieving its concrete value from the message attribute is done just like with regular variables.



<a name="loio86777377f3b049cc98c080819c18eae3__section_w13_ddp_nkb"/>

## Cross-Site Request Forgery Protection

HTTP requests using methods GET, HEAD and OPTIONS are not considered vulnerable to CSRF \(cross-site request forgery\) and therefore no CSRF protection is in place.

For all other HTTP methods CSRF protection is active and needs to be bypassed by one of two ways:

-   Set the HTTP header X-Requested-With to a non-empty value \(this is what an AJAX request would do without losing the ability to authenticate via session cookie\).

-   Authenticate with Authorization: Bearer <token\> header \(this is what a client library would likely use\).


